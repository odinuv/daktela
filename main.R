
# Libraries ---------------------------------------------------------------

## API calls with R
suppressPackageStartupMessages(library(httr))
## Data wrangling - equivalent to pandas + piping
suppressPackageStartupMessages(library(dplyr, quietly = TRUE))
suppressPackageStartupMessages(library(data.table, quietly = TRUE))
## Json parsinf (fromJson)
suppressPackageStartupMessages(library(jsonlite, quietly = TRUE))
## Functional programming - map, reduce functions
suppressPackageStartupMessages(library(purrr, quietly = TRUE))
## Reading and writing CSV files and other formats (--ditch this if ff solves the problem)
suppressPackageStartupMessages(library(readr, quietly = TRUE))
## Operations with dates
suppressPackageStartupMessages(library(lubridate, quietly = TRUE))
## string manipulation
suppressPackageStartupMessages(library(stringr, quietly = TRUE))

# Input config ------------------------------------------------------------


## initialize keboola application this saves all user inputs from the extractor to variables
library('keboola.r.docker.application')
app <- DockerApplication$new('/data/')

app$readConfig()

## Daktela username
user<-app$getParameters()$user
## Daktela password
pwd<-app$getParameters()$'#pwd'
## Daktela server url
url<-app$getParameters()$url
## The date
days_past<-app$getParameters()$from
## Incremental load
increment<-app$getParameters()$incremental

## Create the date from where we take data
days_past<-ifelse(is.null(days_past),1,as.numeric(days_past))

from<-Sys.Date()-days_past

##Catch config errors
if(is.null(pwd) | is.null(user) | is.null(url) ) stop("invalid credentials or site URL")

## Retrieve token
token<-POST(paste0(url,"/api/v6/login.json"),body=list(password=pwd,username=user,only_token=1))%>%
  content("text",encoding = "UTF-8")%>%fromJSON(flatten=TRUE,simplifyDataFrame = TRUE)%>%.$result

# Function definition -----------------------------------------------------
sanitize<-function(df,names_unique){
  missing_cols<-dplyr::setdiff(names_unique,names(df))
  if(!is_empty(missing_cols)){
    #write(paste0("Colum ",missing_cols, " is missing, inserting null values"), stdout())
    df[,missing_cols]<-''
  }
  
  df%>%select(names_unique)
}

#' Parse
#' Default parser for the JSON response of the Daktela API
#'
#' @param response
#'
#' @return dataframe

parse <-
  function(r) {
    res <- r %>% fromJSON(flatten = TRUE, simplifyDataFrame = TRUE) %>%
      .$result %>%
      .$data %>% select(-contains(".")) %>%
      #By default I drop all the objects that are nested
      .[, sapply(., class) != "list"] %>%
      as_data_frame
  }

#This function paginates through an endpoint in parallel and writes the result to the out bucket
#' Write Endporint
#' This function by default paginates through and endpoint a and writes the resulting rows to a CSV file
#' Since some enpoints returns nested lists the function ignores those and returns just the uppermost level
#' as dataframe. If this happens it is necessary to define an iterator function which takes desired elements
#' from the nested lists and puts them in the uppermost level.
#'
#' @param endpoint endpoint attribute list for the api call containting:
#'  endpoint url [1],
#'  endpoint time filter atribute name [2],
#'  endpoint name [3]
#' @param token token generated by calling /api/v6/login.json
#' @param from the date used to filter data from until now.
#' @param limit maximum number of lines to be returned. The default value is 1000
#' @param iterator function used to parse data when nonstandart rules apply for the particular endpoint
#'
#' @return prints a message stating if the task is completed
#' @export csv file.
#'
#' @examples
#'
write_endpoint<-function(endpoint,token,from=NULL,limit=1000,iterator=parse){
  
  #Record task start time
  a<-Sys.time()
  
  ## Looking wether the time filter is applied and changing the endpoint url accordingly
  endpoint_url<-if_else(is.null(from) | endpoint[[2]]==FALSE,
                        #FALSE - without filter
                        endpoint[[1]],
                        #TRUE - with time filter
                        paste0(endpoint[[1]],"?filter[field]=",endpoint[[2]],"&filter[operator]=gte&filter[value]=",from))
  
  ## Filtering example /api/v6/contacts.json?filter[field]=Time&filter[operator]=gte&filter[value]=2018-01-01
  
  #create the endpoint url
  call<-paste0(url,endpoint_url)
  
  #get the size of the list
  total<-GET(call,query=list(accessToken=token,skip=0,take=1))%>%
    content("text",encoding = "UTF-8")%>%fromJSON(flatten=TRUE,simplifyDataFrame = FALSE)%>%.$result%>%.$total
  
  #continue only if size of the list >0
  if(total<1){
    write(paste0("Report ",endpoint[[3]], " is empty for selected criteria "), stdout())
    rows_fetched<-0
  } else {
    
    #creating a sequence reflecting pagination limits
    i=seq(0,total,by = limit)
    
    rows_fetched<-map(i,function(i){
      #Call the api
      tryCatch(
      {res<-GET(call,query=list(accessToken=token,skip=i%>%as.integer,take=limit))%>%
        #Return the json
        content("text",encoding = "UTF-8")%>%
        #Use the parse function
        iterator%>%
        #Check if all rows in the names list are present
        sanitize(endpoint[[4]])
      
      #If i = 0 then initialize the file else append the csv using fwrite from data.table in order to not waste RAM
      fwrite(res,paste0("/data/out/tables/",endpoint[[3]],".csv"),append = ifelse(i>0,TRUE,FALSE), sep=",", sep2=c("{","|","}"))
      
      cnt<-nrow(res) },
      error=function(e){print(paste0("iteration: ",as.integer(i)%>%as.character, "failed. Error: ",message(e))); return(0)})
      
    })%>%unlist%>%as.numeric%>%sum() 
     if (endpoint[[3]]=="activitiesCall") {
           app$writeTableManifest(paste0("/data/out/tables/",endpoint[[3]],".csv"),destination='', primaryKey =c('id_call'),incremental=TRUE)
   } else {
          app$writeTableManifest(paste0("/data/out/tables/",endpoint[[3]],".csv"),destination='', primaryKey =c('name'),incremental= TRUE)
         }
  }
  
  #Writing a message to the console
  b<-Sys.time()
  write(paste0("Task ",endpoint[[3]],": ",rows_fetched ,"/",total," records extracted, task duration: ",time<-round(difftime(b,a,units="secs")%>%as.numeric,2)," s"), stdout())
  
  #Process log info
  ## Check if out_log.csv exists
  logfile_created<-file.exists("out/tables/out_log.csv")
  
  log<-data_frame("date"=Sys.time(),"endpoint"=endpoint[[3]],"exported_records"=total,"extraction_time"=time)
  fwrite(log,"/data/out/tables/out_log.csv",append=logfile_created)
}

  app$writeTableManifest("/data/out/tables/out_log.csv",destination='', primaryKey =c('date','endpoint'), incremental=TRUE)


# Extraction of endpoints -------------------------------------------------
#This section defines the subroutines used for particular endpoints.

## Activities
names_activities<-c("title",       "action",      "type" ,       "survey",      "record",      "priority",    "description", "time",        "time_wait",  
                    "time_open",   "time_close",  "name",        "important" )

activities<-list("/api/v6/activities.json","time","activities",names_activities)
write_endpoint(activities,token,from = from)

## ActivitiesCall
names_activitiesCall<-c("id_call" ,            "call_time",           "direction",           "answered",            "clid",               
                        "prefix_clid_name",    "did",                 "waiting_time",        "ringing_time",        "hold_time",          
                        "duration",            "orig_pos",            "position",            "disposition_cause",   "disconnection_cause",
                        "pressed_key",         "missed_call",         "missed_call_time",    "attempts",            "score",              
                        "note",                "qa_user_id",          "name",                "queue",               "queue_title",        
                        "agent_title","queue_id")

activitiesCall<-list("/api/v6/activitiesCall.json","call_time","activitiesCall",names_activitiesCall)

### Iterator function for Activities Call transformation
iterator_activitiesCall<-function(r){
  clean<-r%>%fromJSON(flatten=TRUE,simplifyDataFrame = TRUE)%>%.$result%>%.$data%>%select(-contains("."))%>%as_data_frame
  df<-r%>%fromJSON(flatten=FALSE,simplifyDataFrame = TRUE)%>%.$result%>%.$data
  df<-data_frame(queue_id=map(df,"name")$id_queue,
                 queue_title=map(df,"title")$id_queue,
                 agent_title=map(df,"title")$id_agent
  )
  out<-clean%>%bind_cols(df)
}
write_endpoint(activitiesCall,token,from = from,iterator = iterator_activitiesCall)

## ActivitiesEmail

names_activitiesEmail<-c( "address",     "direction",   "wait_time",   "duration",    "answered",    "text",        "time",        "name",        "title",     
                          "queue_title", "queue_id"  )

activitiesEmail<-list("/api/v6/activitiesEmail.json","time","activitiesEmail",names_activitiesEmail)

### Iterator function for Activities Email transformation
iterator_activitiesEmail<-function(r){
  clean<-r%>%fromJSON(flatten=TRUE,simplifyDataFrame = TRUE)%>%.$result%>%.$data%>%select(-contains("."))%>%as_data_frame
  df<-r%>%fromJSON(flatten=FALSE,simplifyDataFrame = TRUE)%>%.$result%>%.$data
  df<-data_frame(queue_title=map(df,"title")$queue,
                 queue_id=map(df,"name")$queue
  )
  out<-clean%>%bind_cols(df)%>%select(-files)
}
write_endpoint(activitiesEmail,token,from = from,iterator = iterator_activitiesEmail)

## ActivitiesChat
names_activitiesChat<- c("title", "email","wait_time","duration","answered","disconnection","time","name",
                         "ip","country_code","country_name","region_code","region_name","city","zip_code","time_zone","latitude",
                         "longitude","metro_code","queue_title","referer","queue_id"
)

activitiesChat<-list("/api/v6/activitiesChat.json","time","activitiesChat",names_activitiesChat)

iterator_activitiesChat<-function(r){
  clean<-r%>%fromJSON(flatten=TRUE,simplifyDataFrame = TRUE)%>%.$result%>%.$data%>%select(-contains("."))%>%as_data_frame
  df<-r%>%fromJSON(flatten=FALSE,simplifyDataFrame = TRUE)%>%.$result%>%.$data
  geo<-map(df,"geoip")$options
  df<-data_frame(queue_title=map(df,"title")$queue,
                 referer=map(df,"referer")$options,
                 queue_id=map(df,"name")$queue
                 
  )
  out<-clean%>%bind_cols(df)%>%bind_cols(geo)
}



write_endpoint(activitiesChat,token,from = from,iterator = iterator_activitiesChat)

## Accounts
names_accounts<-c("title",
                  "survey",
                  "description",
                  "deleted",
                  "name")

accounts<-list("/api/v6/accounts.json",FALSE,"accounts",names_accounts)

write_endpoint(accounts,token,from = from)

## Groups

names_groups<-c("title",
                "description",
                "type",
                "deleted",
                "name")
groups<-list("/api/v6/groups.json",FALSE,"groups",names_groups)

write_endpoint(groups,token,from = from)

## Pauses

names_pauses<-c("name",
                "title",
                "paid",
                "type",
                "max_duration",
                "calculated_from",
                "auto_pause",
                "deleted")

pauses<-list("/api/v6/pauses.json",FALSE,"pauses",names_pauses)

write_endpoint(pauses,token,from = from)

## Queues
names_queues<-c("title",
                "description",
                "type",
                "direction",
                "deactivated",
                "deleted",
                "name",
                "usersCount" )

queues<-list("/api/v6/queues.json",FALSE,"queues",names_queues)

write_endpoint(queues,token,from = from)

## Statuses
names_statuses<-c("title",
                  "validation",
                  "nextcall",
                  "blacklist_database",
                  "blacklist_expiration_time",
                  "color",
                  "deleted",
                  "name" )

statuses<-list("/api/v6/statuses.json",FALSE,"statuses",names_statuses)

write_endpoint(statuses,token,from = from)

## Templates
names_templates<-c("title",
                   "description",
                   "format",
                   "usingtype",
                   "content",
                   "deleted",
                   "id_template",
                   "name")

templates<-list("/api/v6/templates.json",FALSE,"templates",names_templates)

write_endpoint(templates,token,from = from)

## Tickets

names_tickets<-c("title",
                 "email",
                 "description",
                 "stage",
                 "priority",
                 "sla_deadtime",
                 "sla_change",
                 "sla_notify",
                 "sla_duration",
                 "sla_custom",
                 "survey",
                 "survey_offered",
                 "satisfaction",
                 "satisfaction_comment",
                 "reopen",
                 "deleted",
                 "created",
                 "edited",
                 "first_answer",
                 "first_answer_duration",
                 "closed",
                 "unread",
                 "has_attachment",
                 "name",
                 "isBookmarked")

tickets<-list("/api/v6/tickets.json","edited","tickets",names_tickets)

write_endpoint(tickets,token,from = from)
